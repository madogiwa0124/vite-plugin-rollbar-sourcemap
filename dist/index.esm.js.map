{"version":3,"file":"index.esm.js","names":["silent: boolean","ignoreUploadErrors: boolean","message: string","error: Error | null","state: { logger: Logger }","value: Logger","message: string","filename: string","statusText: string","body: FormData","sourceMappings: SourceMapping[]","accessToken: string","version: string","baseUrl: string","error: unknown","form: FormData","fileName: string","souceMapGlob: string","outputDir: string","sourceMapFile: string","sourceMapPath: string","base: string","outputDir: string"],"sources":["../src/logger.ts","../src/state.ts","../src/rollbar/errors.ts","../src/rollbar/service.ts","../src/rollbar/client.ts","../src/sourceMap/util.ts","../src/sourceMap/index.ts","../src/index.ts"],"sourcesContent":["export class Logger {\n  silent: boolean;\n  ignoreUploadErrors: boolean;\n  constructor(silent: boolean, ignoreUploadErrors: boolean) {\n    this.silent = silent;\n    this.ignoreUploadErrors = ignoreUploadErrors;\n  }\n\n  info(message: string) {\n    if (!this.silent) console.log(message);\n    return null;\n  }\n\n  error(message: string, error: Error | null = null) {\n    if (!this.silent) console.error(message);\n    if (error && !this.ignoreUploadErrors) throw error;\n    return null;\n  }\n}\n\nexport const buildLogger = (silent: boolean, ignoreUploadErrors: boolean) => {\n  return new Logger(silent, ignoreUploadErrors);\n};\n","import { Logger } from \"./logger\";\n\nexport const state: { logger: Logger } = {\n  logger: new Logger(false, true),\n};\n\nexport const setLogger = (value: Logger) => {\n  state.logger = value;\n};\n","export class FailedUploadError extends Error {\n  constructor(message: string, filename: string) {\n    super(message);\n    this.message = `Failed to upload ${filename} to Rollbar: ${message}.`;\n    this.name = \"FailedUploadError\";\n  }\n}\n\nexport class FailedPostError extends Error {\n  constructor(message: string, statusText: string) {\n    super(message);\n    this.message = `Failed to post sourcemap to Rollbar with ${statusText}: ${message}.`;\n    this.name = \"FaildPostError\";\n  }\n}\n","const ROLLBAR_ENDPOINT = \"https://api.rollbar.com/api/1/sourcemap\";\nexport const postRollbarSourcemap = async (body: FormData): Promise<Response> => {\n  const res = await fetch(ROLLBAR_ENDPOINT, { method: \"POST\", body });\n  return res;\n};\n\nif (import.meta.vitest) {\n  const { describe, it, expect, vi } = import.meta.vitest;\n\n  describe(\"postRollbarSourcemap\", () => {\n    it(\"should post sourcemap to Rollbar\", async () => {\n      vi.spyOn(global, \"fetch\").mockImplementation(\n        async () => new Response('{ \"key\": \"value\" }', { status: 200 }),\n      );\n      const form = new FormData();\n      const res = await postRollbarSourcemap(form);\n      expect(global.fetch).toBeCalledWith(ROLLBAR_ENDPOINT, {\n        method: \"POST\",\n        body: form,\n      });\n      expect(res.ok).toBe(true);\n    });\n  });\n}\n","import type { SourceMapping } from \"../sourceMap\";\nimport { state } from \"../state\";\nimport { FailedPostError, FailedUploadError } from \"./errors\";\nimport { postRollbarSourcemap } from \"./service\";\n\nexport const uploadAllSourceMaps = async (\n  sourceMappings: SourceMapping[],\n  accessToken: string,\n  version: string,\n  baseUrl: string,\n): Promise<void> => {\n  try {\n    await Promise.all(\n      sourceMappings.map((mapping): Promise<void> => {\n        const { sourceMapContent, sourceMapFilePath, originalFileUrl } = mapping;\n        const minifiedUrl = `${baseUrl}${originalFileUrl}`;\n        const form = buildPostFormData({\n          accessToken,\n          version,\n          minifiedUrl,\n          sourceMapContent,\n          sourceMapFilePath,\n        });\n        return uploadSourcemap(form, originalFileUrl);\n      }),\n    );\n  } catch (error: unknown) {\n    state.logger.error(`Failed to upload sourcemap: ${error}.`, error as Error);\n  }\n};\n\nconst uploadSourcemap = async (form: FormData, fileName: string): Promise<void> => {\n  try {\n    const res = await postRollbarSourcemap(form);\n    if (!res.ok) throw new FailedPostError(await res.text(), res.statusText);\n    state.logger.info(`Uploaded ${fileName} to Rollbar.`);\n  } catch (error: unknown) {\n    throw new FailedUploadError((error as Error).message, fileName);\n  }\n};\n\nconst buildPostFormData = ({\n  accessToken,\n  version,\n  minifiedUrl,\n  sourceMapContent,\n  sourceMapFilePath,\n}: {\n  accessToken: string;\n  version: string;\n  minifiedUrl: string;\n  sourceMapContent: string;\n  sourceMapFilePath: string;\n}): FormData => {\n  const form = new FormData();\n  form.set(\"access_token\", accessToken);\n  form.set(\"version\", version);\n  form.set(\"minified_url\", minifiedUrl);\n  form.set(\"source_map\", new Blob([sourceMapContent]), sourceMapFilePath);\n  return form;\n};\n","import { existsSync, globSync, readFileSync } from \"node:fs\";\nimport { resolve } from \"node:path\";\n\nexport const collectSourceMapFiles = (souceMapGlob: string, outputDir: string): string[] => {\n  return globSync(souceMapGlob, { cwd: outputDir });\n};\n\nexport const resolveSourceMapFile = (outputDir: string, sourceMapFile: string): string => {\n  return resolve(outputDir, sourceMapFile);\n};\n\nexport const calcSourceFile = ({\n  sourceMapFile,\n  outputDir,\n}: {\n  sourceMapFile: string;\n  outputDir: string;\n}): string | null => {\n  const sourceFile = sourceMapFile.replace(/\\.map$/, \"\");\n  const sourcePath = resolve(outputDir, sourceFile);\n  if (!existsSync(sourcePath)) return null;\n  return sourceFile;\n};\n\nexport const readSourceMapFile = (sourceMapPath: string): string => {\n  return readFileSync(sourceMapPath, \"utf8\");\n};\n\nif (import.meta.vitest) {\n  const { describe, it, expect } = import.meta.vitest;\n\n  describe(\"collectSourceMapFiles\", () => {\n    it(\"should collect source map files\", () => {\n      const result = collectSourceMapFiles(\"**/*.map\", \"test/sample\");\n      expect(result).toEqual([\"bar.js.map\", \"foo.js.map\"]);\n    });\n  });\n\n  describe(\"resolveSourceMap\", () => {\n    it(\"should resolve source map file path\", () => {\n      const result = resolveSourceMapFile(\"test/sample\", \"foo.js.map\");\n      expect(result).toBe(resolve(\"test/sample/foo.js.map\"));\n    });\n  });\n\n  describe(\"calcSourcePath\", () => {\n    it(\"should calculate source path\", () => {\n      const result = calcSourceFile({\n        sourceMapFile: \"foo.js.map\",\n        outputDir: \"test/sample\",\n      });\n      expect(result).toBe(\"foo.js\");\n    });\n  });\n}\n","import { state } from \"../state\";\nimport {\n  calcSourceFile,\n  collectSourceMapFiles,\n  readSourceMapFile,\n  resolveSourceMapFile,\n} from \"./util\";\n\nexport type SourceMapping = {\n  sourceMapContent: string;\n  sourceMapFilePath: string;\n  originalFileUrl: string;\n};\n\nconst SOURCE_MAP_GLOB = \"./**/*.map\";\nexport const collectSourceMappings = async (\n  base: string,\n  outputDir: string,\n  sourceMapGlob = SOURCE_MAP_GLOB,\n): Promise<SourceMapping[]> => {\n  const sourceMapFiles = collectSourceMapFiles(sourceMapGlob, outputDir);\n  const sourceMappings = sourceMapFiles.map((sourceMapFile) => {\n    const sourcePath = calcSourceFile({ sourceMapFile, outputDir });\n    if (sourcePath === null) return state.logger.error(`No source found for '${sourceMapFile}'.`);\n\n    const sourceMapFilePath = resolveSourceMapFile(outputDir, sourceMapFile);\n    return buildSourceMapping({ base, sourcePath, sourceMapFilePath });\n  });\n  return sourceMappings.filter((mapping) => mapping !== null);\n};\n\nconst buildSourceMapping = ({\n  base,\n  sourcePath,\n  sourceMapFilePath,\n}: {\n  base: string;\n  sourcePath: string;\n  sourceMapFilePath: string;\n}): SourceMapping | null => {\n  const originalFileUrl = `${base}${sourcePath}`;\n  try {\n    const sourceMapContent = readSourceMapFile(sourceMapFilePath);\n    return { sourceMapContent, sourceMapFilePath, originalFileUrl };\n  } catch (_error) {\n    state.logger.error(`Error reading sourcemap file: ${sourceMapFilePath}`);\n    return null;\n  }\n};\n","import type { Plugin } from \"vite\";\nimport { buildLogger } from \"./logger\";\nimport { uploadAllSourceMaps } from \"./rollbar/client\";\nimport { collectSourceMappings } from \"./sourceMap\";\nimport { setLogger } from \"./state\";\n\nexport type RollbarSourcemapsOptions = {\n  accessToken: string;\n  version: string;\n  baseUrl: string;\n  silent?: boolean;\n  ignoreUploadErrors?: boolean;\n  base?: string;\n  outputDir?: string;\n};\n\nexport default function vitePluginRollbarSourceMap({\n  accessToken,\n  version,\n  baseUrl,\n  silent = false,\n  ignoreUploadErrors = true,\n  base = \"/\",\n  outputDir = \"dist\",\n}: RollbarSourcemapsOptions): Plugin {\n  return {\n    name: \"vite-plugin-rollbar-sourcemap\",\n    async writeBundle() {\n      setLogger(buildLogger(silent, ignoreUploadErrors));\n      const sourceMappings = await collectSourceMappings(base, outputDir);\n      if (!sourceMappings.length) return;\n      await uploadAllSourceMaps(sourceMappings, accessToken, version, baseUrl);\n    },\n  };\n}\n"],"mappings":"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"}